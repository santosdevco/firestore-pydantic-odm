name: Release

on:
  pull_request:
    types: [closed]
    branches: [master]

permissions:
  contents: write

jobs:
  # ── Step 1: Run integration tests against REAL Firestore ────────────
  test-real-firestore:
    if: github.event.pull_request.merged == true
    name: "Real Firestore — Py ${{ matrix.python-version }} / ${{ matrix.pydantic-version }}"
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]
        pydantic-version:
          - "pydantic>=1.5,<2.0"
          - "pydantic>=2.0,<2.11"
          - "pydantic>=2.11"
        exclude:
          - python-version: "3.12"
            pydantic-version: "pydantic>=1.5,<2.0"

    steps:
      - uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          missing=()
          [[ -z "${{ secrets.GCP_SA_KEY }}"      ]] && missing+=("GCP_SA_KEY")
          [[ -z "${{ secrets.GCP_PROJECT_ID }}"  ]] && missing+=("GCP_PROJECT_ID")
          if [[ ${#missing[@]} -gt 0 ]]; then
            echo "❌ The following required GitHub secrets are not set: ${missing[*]}"
            echo "   Configure them at: Settings → Secrets and variables → Actions"
            exit 1
          fi
          echo "✅ All required secrets are present."

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: pip

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install "${{ matrix.pydantic-version }}"
          pip install -e ".[dev]"

      - name: Configure GCP credentials
        run: |
          echo "${{ secrets.GCP_SA_KEY }}" | base64 -d > /tmp/sa-key.json

      - name: Run unit tests
        run: pytest tests/ -v --tb=short --ignore=tests/integration

      - name: Run integration tests (real Firestore)
        run: pytest tests/integration/ -v --tb=short
        env:
          GOOGLE_APPLICATION_CREDENTIALS: /tmp/sa-key.json
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          DATABASE: ${{ secrets.GCP_DATABASE }}

      - name: Cleanup credentials
        if: always()
        run: rm -f /tmp/sa-key.json

  # ── Gate: all real-firestore tests must pass ────────────────────────
  release-gate:
    name: "All real Firestore tests passed"
    runs-on: ubuntu-latest
    needs: test-real-firestore
    if: always()
    steps:
      - name: Check result
        run: |
          if [[ "${{ needs.test-real-firestore.result }}" != "success" ]]; then
            echo "Real Firestore tests failed — aborting release."
            exit 1
          fi

  # ── Step 2: Version bump + tag + publish ────────────────────────────
  release:
    needs: release-gate
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0          # full history needed for version calculation
          token: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Read current version from setup.py
        id: current
        run: |
          version=$(python3 -c "
          import re, pathlib
          text = pathlib.Path('setup.py').read_text()
          m = re.search(r'version\s*=\s*\"([^\"]+)\"', text)
          print(m.group(1))
          ")
          echo "version=$version" >> "$GITHUB_OUTPUT"

      - name: Calculate next version
        id: next
        run: |
          current="${{ steps.current.outputs.version }}"
          echo "Current version: $current"

          # Parse major.minor.patch
          IFS='.' read -r major minor patch <<< "$current"

          # Determine bump type from commit messages since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --oneline)
          else
            COMMITS=$(git log "${LAST_TAG}..HEAD" --oneline)
          fi

          echo "Commits since last tag:"
          echo "$COMMITS"

          # Check commit messages for bump keywords
          if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|^.*!:"; then
            bump="major"
          elif echo "$COMMITS" | grep -qiE "^feat|^feature"; then
            bump="minor"
          else
            bump="patch"
          fi

          echo "Bump type: $bump"

          case $bump in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          new_version="${major}.${minor}.${patch}"
          echo "New version: $new_version"
          echo "version=$new_version" >> "$GITHUB_OUTPUT"

      - name: Update version in setup.py
        run: |
          sed -i 's/version="${{ steps.current.outputs.version }}"/version="${{ steps.next.outputs.version }}"/' setup.py
          echo "Updated setup.py:"
          grep 'version=' setup.py

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add setup.py
          git commit -m "chore: bump version to ${{ steps.next.outputs.version }}"
          git push origin master --force-with-lease

      - name: Create and push tag
        run: |
          git tag "v${{ steps.next.outputs.version }}"
          git push origin "v${{ steps.next.outputs.version }}"

      - name: Generate release notes
        id: notes
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            NOTES=$(git log --oneline --pretty=format:"- %s" | head -50)
          else
            NOTES=$(git log "${LAST_TAG}..HEAD^" --oneline --pretty=format:"- %s")
          fi

          # Write multiline output
          {
            echo "notes<<EOF"
            echo "$NOTES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ steps.next.outputs.version }}"
          name: "v${{ steps.next.outputs.version }}"
          body: |
            ## What's Changed

            ${{ steps.notes.outputs.notes }}

            **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ steps.current.outputs.version && format('v{0}', steps.current.outputs.version) || '' }}...v${{ steps.next.outputs.version }}
          generate_release_notes: true
